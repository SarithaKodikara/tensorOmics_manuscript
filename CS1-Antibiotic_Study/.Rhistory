tags$p(HTML("<b>Degree:</b> how many friends you have.<br/>
<b>Betweenness:</b> how often you sit on the shortest path between others — a bridge.<br/>
<b>Closeness:</b> how close you are to everyone else, on average.<br/>
<b>Eigenvector:</b> connected to other important people.<br/>
<b>PageRank:</b> like how search engines rank pages."))
)
)
)
)
)
#--- Server --------------------------------------------------------------------
server <- function(input, output, session) {
g_reactive <- reactiveVal(make_graph())
observeEvent(input$regen, {
g_reactive(make_graph(input$n, input$p, input$seed))
}, ignoreInit = TRUE)
observeEvent(NULL, { # initial compute
g_reactive(make_graph(input$n, input$p, input$seed))
}, once = TRUE)
# Build visNetwork for current graph
net_data <- reactive({
req(g_reactive())
vis_from_igraph(g_reactive(), cent_name = input$cent, top_k = input$topk)
})
# Coach text to prompt audience interaction
output$coach1 <- renderUI({
HTML(paste0(
"<h4>Can you spot the influencers?</h4>",
"Try changing the <b>centrality measure</b> or <b>top-k</b>, then ask the audience: ",
"<i>Why did the highlighted people change?</i>"
))
})
output$net <- renderVisNetwork({
nd <- net_data()$nodes
ed <- net_data()$edges
visNetwork(nd, ed) %>%
visIgraphLayout(randomSeed = 42) %>%
visOptions(highlightNearest = list(enabled = TRUE, degree = 1),
nodesIdSelection = TRUE) %>%
visPhysics(stabilization = TRUE) %>%
visLegend(useGroups = TRUE) %>%
visEdges(smooth = FALSE)
})
# Simple network stats (components, average degree)
output$stats <- renderUI({
g <- g_reactive()
cc <- components(g)
HTML(sprintf(
"<b>Quick facts:</b> nodes = %d, edges = %d, components = %d, average degree = %.2f",
vcount(g), ecount(g), cc$no, mean(degree(g))
))
})
# Remove top influencer and show new network
removed <- eventReactive(input$remove, {
req(g_reactive())
remove_top_influencer(g_reactive(), cent_name = input$cent)
})
output$coach2 <- renderUI({
if (is.null(removed())) {
HTML("<h4>Click 'Remove Top Influencer' to see what changes</h4>")
} else {
HTML(paste0(
"<h4>We removed Student <b>", removed()$removed,
"</b>. What changed?</h4> Ask: Did the network split? Who is important now?"
))
}
})
net_removed_data <- reactive({
req(removed())
vis_from_igraph(removed()$g2, cent_name = input$cent, top_k = input$topk)
})
output$net_removed <- renderVisNetwork({
req(net_removed_data())
nd <- net_removed_data()$nodes
ed <- net_removed_data()$edges
visNetwork(nd, ed) %>%
visIgraphLayout(randomSeed = 21) %>%
visOptions(highlightNearest = list(enabled = TRUE, degree = 1),
nodesIdSelection = TRUE) %>%
visPhysics(stabilization = TRUE) %>%
visLegend(useGroups = TRUE) %>%
visEdges(smooth = FALSE)
})
output$stats2 <- renderUI({
req(removed())
g2 <- removed()$g2
cc <- components(g2)
HTML(sprintf(
"<b>After removal:</b> nodes = %d, edges = %d, components = %d, average degree = %.2f",
vcount(g2), ecount(g2), cc$no, mean(degree(g2))
))
})
}
shinyApp(ui, server)
set.seed(9999)
# Loading plot function
loadingPlot<-function(loadings, top=8 ,merged_df,comp= 1,
negGroup=NULL, posGroup=NULL){
# Extract loadings for the specified component
loadings_cmp <- loadings[, comp]
names(loadings_cmp)<-colnames(merged_df[, -c(1:3) ])
# Calculate the absolute values and sort the indices based on absolute values
sorted_indices<- order(abs(loadings_cmp), decreasing = TRUE)
# Sort the categories and values based on the sorted indices
sorted_comp <- colnames(merged_df[, -c(1:3) ])[sorted_indices[1:top]]
sorted_loadings_comp <- loadings_cmp[sorted_comp[1:top]]
max_loading<- max(abs(sorted_loadings_comp))
# Create a temporary data frame for plotting
tmp_df <- data.frame(
OTU = sorted_comp,
loading = sorted_loadings_comp
)
tmp_df$OTU<- factor(tmp_df$OTU, levels = sorted_comp)
# Assign sign and y-position for each category
tmp_df <- tmp_df %>%
mutate(sign = ifelse(loading >= 0, "positive", "negative")) %>%
mutate(ypos = as.numeric(OTU))
# Prepare data for plotting
merged_df_sel <-merged_df[,c("group", "time", "id", sorted_comp)]
merged_df_mean <- merged_df_sel %>%
summarise(
.by = c(group, time),                 # grouping done here
across(
all_of(sorted_comp),
~ mean(.x, na.rm = TRUE),
.names = "{.col}"                      # clearer column names
)
)
# Reshape data to long format for ggplot
long_dat <-pivot_longer(
merged_df_mean,
cols = -c(group, time),
names_to = "OTU",
values_to = "median_value"
)
long_dat$OTU <- factor(long_dat$OTU, levels = sorted_comp)
# Assign y-position for each category
long_dat <- long_dat %>% mutate(ypos = as.numeric(OTU))
# Merge with tmp_df to get loading information
long_dat <- long_dat %>%
left_join(tmp_df%>%select(OTU, loading), by = "OTU")%>%
mutate(sign_type = ifelse(loading >= 0, "positive", "negative"),
alpha_label = ifelse((sign_type == "positive" & group %in% posGroup), "High alpha",
ifelse((sign_type == "negative" & group %in% negGroup), "High alpha", "Low alpha")))%>%
group_by(OTU) %>%
mutate(value_scaled = rescale(median_value, to = c(unique(ypos) - 0.4, unique(ypos) + 0.4))) %>%
mutate(time = rescale(time, to = c(0, max_loading)))%>%
ungroup()
# Plot
custom_colors <- c("A" = "blue", "B" = "orange")
P<-ggplot(long_dat, aes(x = time)) +
geom_rect(data = tmp_df,
aes(xmin = pmin(0, -abs(loading)/3), xmax = pmax(0, -abs(loading)),
ymin = ypos - 0.4, ymax = ypos + 0.4, fill = sign),
alpha = 0.8, inherit.aes = FALSE)+
scale_y_continuous(breaks = 1:top, labels = sorted_comp) +
scale_fill_manual(
values = c(positive ="#d73027", negative = "#4575b4"),
name   = "Loading"
) +
guides(fill = guide_legend(reverse = TRUE))+
ggnewscale::new_scale_fill() +
geom_ribbon(aes(ymin = ypos - 0.4, ymax = ypos + 0.4,
group = interaction(group, OTU),
fill = sign_type),
alpha = 0.02, show.legend = FALSE) +
scale_fill_manual(
values = c(positive ="#d73027", negative = "#4575b4"),
name = "Loading"
)+
geom_line(aes(y = value_scaled,
group = interaction(group, OTU),
colour = group,
linetype = alpha_label,
alpha = alpha_label),
linewidth   = 1)+
scale_color_manual(values = custom_colors, name = "Group") +
scale_alpha_manual(values = c("High alpha" = 1, "Low alpha" = 0.35), guide = "none") +
scale_linetype_manual(values = c("High alpha" = 1, "Low alpha" = 2), guide = "none") +
scale_x_continuous(
breaks = waiver(),
labels = function(b) ifelse(b == 0, "0", "")
) +
labs(y = "",
title = "") +
theme_minimal() +
theme(
panel.grid.major = element_blank(),
axis.line.x = element_line(),
legend.position = "bottom",
plot.margin = margin(20, 10, 60, 10),
axis.text = element_text(size = 12)
) +
annotate("text", x = max_loading/2, y = min(tmp_df$ypos) - 0.6, label = "Time", size = 4.5) +
annotate("text", x = (-max_loading)/5-0.001, y = min(tmp_df$ypos) - 0.6, label = "|Loading|", size = 4.5) +
geom_vline(xintercept = 0, colour = "black", linetype = "dashed") +
labs(x = NULL)
return(P)
}
# Simulate longitudinal data
n <- 10; p <- 15; t <- 5
time <- 0:(t - 1)
grp <- rep(c("A", "B"), each = n/2)
sigma_eps <- 0.25
sigma_id  <- 0.3
# Initialize array to hold data
Y <- array(0, dim = c(n, p, t), dimnames = list(
id = paste0("S", seq_len(n)),
var = paste0("V", seq_len(p)),
time = paste0("T", seq_len(t))
))
# Subject-specific random effects
id_re <- matrix(rnorm(n * p, 0, sigma_id), nrow = n, ncol = p,
dimnames = list(paste0("S", seq_len(n)), paste0("V", seq_len(p))))
# Generate data with group-specific trajectories
add_noise <- function(mu) mu + rnorm(length(mu), 0, sigma_eps)
for (i in seq_len(n)) {
g <- grp[i]
mu1 <- if (g == "A") 0.6 * time else rep(0, t)
Y[i, "V1", ] <- add_noise(mu1 + id_re[i, "V1"])
mu2 <- if (g == "B") 0.6 * time else rep(0, t)
Y[i, "V2", ] <- add_noise(mu2 + id_re[i, "V2"])
mu3 <- if (g == "A") 1.0 else 0.0
Y[i, "V3", ] <- add_noise(rep(mu3, t) + id_re[i, "V3"])
mu4 <- if (g == "B") 1.0 else 0.0
Y[i, "V4", ] <- add_noise(rep(mu4, t) + id_re[i, "V4"])
mu5 <- if (g == "A") 0.5 * time else -0.5 * time
Y[i, "V5", ] <- add_noise(mu5 + id_re[i, "V5"])
for (v in paste0("V", 6:15)) {
drift <- runif(1, -0.1, 0.1) * time
Y[i, v, ] <- add_noise(drift + id_re[i, v])
}
}
# Convert to long format for ggplot
to_long <- function(Y, grp) {
df <- as.data.frame.table(Y, responseName = "value")
names(df) <- c("id", "variable", "time", "value")
df$time <- as.integer(sub("T", "", df$time))
df$group <- grp[match(df$id, unique(df$id))]
df[, c("id", "group", "time", "variable", "value")]
}
dat_long <- to_long(Y, grp)
# summary stats per variable × group × time
group_summ <- dat_long %>%
group_by(variable, group, time) %>%
summarise(
n    = dplyr::n(),
mean = mean(value),
sd   = sd(value),
se   = sd / sqrt(n),
tcrit = qt(0.975, df = pmax(n - 1, 1)),
lo   = mean - tcrit * se,
hi   = mean + tcrit * se,
.groups = "drop"
)
ggplot() +
geom_point(data = dat_long,
aes(x = time, y = value, color = group),
alpha = 0.25, size = 1) +
# individual trajectories (lighter)
geom_line(
data = dat_long,
aes(x = time, y = value, color = group, group = interaction(id, group)),
alpha = 0.25, size = 0.5
) +
# CI ribbons per group
geom_ribbon(
data = group_summ,
aes(x = time, ymin = lo, ymax = hi, fill = group, group = group),
alpha = 0.20, color = NA
) +
# group mean lines
geom_line(
data = group_summ,
aes(x = time, y = mean, color = group, group = group),
size = 1.2
) +
facet_wrap(~ variable, scales = "free_y", ncol = 5) +
theme_bw(base_size = 12) +
scale_color_manual(values = c("A" = "blue", "B" = "orange")) +
scale_fill_manual(values = c("A" = "blue", "B" = "orange")) +
labs(
x = "Time point",
y = "Value",
color = "Group",
fill  = "Group",
title = ""
) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
strip.background = element_rect(fill = "grey90"),
legend.position = "top"
)
library(mixOmics)
library(dplyr)
library(tidyr)
library(plotly)
library(gridExtra)
library(patchwork)
library(scales)
library(ggplot2)
set.seed(9999)
# Loading plot function
loadingPlot<-function(loadings, top=8 ,merged_df,comp= 1,
negGroup=NULL, posGroup=NULL){
# Extract loadings for the specified component
loadings_cmp <- loadings[, comp]
names(loadings_cmp)<-colnames(merged_df[, -c(1:3) ])
# Calculate the absolute values and sort the indices based on absolute values
sorted_indices<- order(abs(loadings_cmp), decreasing = TRUE)
# Sort the categories and values based on the sorted indices
sorted_comp <- colnames(merged_df[, -c(1:3) ])[sorted_indices[1:top]]
sorted_loadings_comp <- loadings_cmp[sorted_comp[1:top]]
max_loading<- max(abs(sorted_loadings_comp))
# Create a temporary data frame for plotting
tmp_df <- data.frame(
OTU = sorted_comp,
loading = sorted_loadings_comp
)
tmp_df$OTU<- factor(tmp_df$OTU, levels = sorted_comp)
# Assign sign and y-position for each category
tmp_df <- tmp_df %>%
mutate(sign = ifelse(loading >= 0, "positive", "negative")) %>%
mutate(ypos = as.numeric(OTU))
# Prepare data for plotting
merged_df_sel <-merged_df[,c("group", "time", "id", sorted_comp)]
merged_df_mean <- merged_df_sel %>%
summarise(
.by = c(group, time),                 # grouping done here
across(
all_of(sorted_comp),
~ mean(.x, na.rm = TRUE),
.names = "{.col}"                      # clearer column names
)
)
# Reshape data to long format for ggplot
long_dat <-pivot_longer(
merged_df_mean,
cols = -c(group, time),
names_to = "OTU",
values_to = "median_value"
)
long_dat$OTU <- factor(long_dat$OTU, levels = sorted_comp)
# Assign y-position for each category
long_dat <- long_dat %>% mutate(ypos = as.numeric(OTU))
# Merge with tmp_df to get loading information
long_dat <- long_dat %>%
left_join(tmp_df%>%select(OTU, loading), by = "OTU")%>%
mutate(sign_type = ifelse(loading >= 0, "positive", "negative"),
alpha_label = ifelse((sign_type == "positive" & group %in% posGroup), "High alpha",
ifelse((sign_type == "negative" & group %in% negGroup), "High alpha", "Low alpha")))%>%
group_by(OTU) %>%
mutate(value_scaled = rescale(median_value, to = c(unique(ypos) - 0.4, unique(ypos) + 0.4))) %>%
mutate(time = rescale(time, to = c(0, max_loading)))%>%
ungroup()
# Plot
custom_colors <- c("A" = "blue", "B" = "orange")
P<-ggplot(long_dat, aes(x = time)) +
geom_rect(data = tmp_df,
aes(xmin = pmin(0, -abs(loading)/3), xmax = pmax(0, -abs(loading)),
ymin = ypos - 0.4, ymax = ypos + 0.4, fill = sign),
alpha = 0.8, inherit.aes = FALSE)+
scale_y_continuous(breaks = 1:top, labels = sorted_comp) +
scale_fill_manual(
values = c(positive ="#d73027", negative = "#4575b4"),
name   = "Loading"
) +
guides(fill = guide_legend(reverse = TRUE))+
ggnewscale::new_scale_fill() +
geom_ribbon(aes(ymin = ypos - 0.4, ymax = ypos + 0.4,
group = interaction(group, OTU),
fill = sign_type),
alpha = 0.02, show.legend = FALSE) +
scale_fill_manual(
values = c(positive ="#d73027", negative = "#4575b4"),
name = "Loading"
)+
geom_line(aes(y = value_scaled,
group = interaction(group, OTU),
colour = group,
linetype = alpha_label,
alpha = alpha_label),
linewidth   = 1)+
scale_color_manual(values = custom_colors, name = "Group") +
scale_alpha_manual(values = c("High alpha" = 1, "Low alpha" = 0.35), guide = "none") +
scale_linetype_manual(values = c("High alpha" = 1, "Low alpha" = 2), guide = "none") +
scale_x_continuous(
breaks = waiver(),
labels = function(b) ifelse(b == 0, "0", "")
) +
labs(y = "",
title = "") +
theme_minimal() +
theme(
panel.grid.major = element_blank(),
axis.line.x = element_line(),
legend.position = "bottom",
plot.margin = margin(20, 10, 60, 10),
axis.text = element_text(size = 12)
) +
annotate("text", x = max_loading/2, y = min(tmp_df$ypos) - 0.6, label = "Time", size = 4.5) +
annotate("text", x = (-max_loading)/5-0.001, y = min(tmp_df$ypos) - 0.6, label = "|Loading|", size = 4.5) +
geom_vline(xintercept = 0, colour = "black", linetype = "dashed") +
labs(x = NULL)
return(P)
}
# Simulate longitudinal data
n <- 10; p <- 15; t <- 5
time <- 0:(t - 1)
grp <- rep(c("A", "B"), each = n/2)
sigma_eps <- 0.25
sigma_id  <- 0.3
# Initialize array to hold data
Y <- array(0, dim = c(n, p, t), dimnames = list(
id = paste0("S", seq_len(n)),
var = paste0("V", seq_len(p)),
time = paste0("T", seq_len(t))
))
# Subject-specific random effects
id_re <- matrix(rnorm(n * p, 0, sigma_id), nrow = n, ncol = p,
dimnames = list(paste0("S", seq_len(n)), paste0("V", seq_len(p))))
# Generate data with group-specific trajectories
add_noise <- function(mu) mu + rnorm(length(mu), 0, sigma_eps)
for (i in seq_len(n)) {
g <- grp[i]
mu1 <- if (g == "A") 0.6 * time else rep(0, t)
Y[i, "V1", ] <- add_noise(mu1 + id_re[i, "V1"])
mu2 <- if (g == "B") 0.6 * time else rep(0, t)
Y[i, "V2", ] <- add_noise(mu2 + id_re[i, "V2"])
mu3 <- if (g == "A") 1.0 else 0.0
Y[i, "V3", ] <- add_noise(rep(mu3, t) + id_re[i, "V3"])
mu4 <- if (g == "B") 1.0 else 0.0
Y[i, "V4", ] <- add_noise(rep(mu4, t) + id_re[i, "V4"])
mu5 <- if (g == "A") 0.5 * time else -0.5 * time
Y[i, "V5", ] <- add_noise(mu5 + id_re[i, "V5"])
for (v in paste0("V", 6:15)) {
drift <- runif(1, -0.1, 0.1) * time
Y[i, v, ] <- add_noise(drift + id_re[i, v])
}
}
# Convert to long format for ggplot
to_long <- function(Y, grp) {
df <- as.data.frame.table(Y, responseName = "value")
names(df) <- c("id", "variable", "time", "value")
df$time <- as.integer(sub("T", "", df$time))
df$group <- grp[match(df$id, unique(df$id))]
df[, c("id", "group", "time", "variable", "value")]
}
dat_long <- to_long(Y, grp)
# summary stats per variable × group × time
group_summ <- dat_long %>%
group_by(variable, group, time) %>%
summarise(
n    = dplyr::n(),
mean = mean(value),
sd   = sd(value),
se   = sd / sqrt(n),
tcrit = qt(0.975, df = pmax(n - 1, 1)),
lo   = mean - tcrit * se,
hi   = mean + tcrit * se,
.groups = "drop"
)
ggplot() +
geom_point(data = dat_long,
aes(x = time, y = value, color = group),
alpha = 0.25, size = 1) +
# individual trajectories (lighter)
geom_line(
data = dat_long,
aes(x = time, y = value, color = group, group = interaction(id, group)),
alpha = 0.25, size = 0.5
) +
# CI ribbons per group
geom_ribbon(
data = group_summ,
aes(x = time, ymin = lo, ymax = hi, fill = group, group = group),
alpha = 0.20, color = NA
) +
# group mean lines
geom_line(
data = group_summ,
aes(x = time, y = mean, color = group, group = group),
size = 1.2
) +
facet_wrap(~ variable, scales = "free_y", ncol = 5) +
theme_bw(base_size = 12) +
scale_color_manual(values = c("A" = "blue", "B" = "orange")) +
scale_fill_manual(values = c("A" = "blue", "B" = "orange")) +
labs(
x = "Time point",
y = "Value",
color = "Group",
fill  = "Group",
title = ""
) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
strip.background = element_rect(fill = "grey90"),
legend.position = "top"
)
data_wide <- pivot_wider(
dat_long,
id_cols = c("id", "group", "time"),
names_from = "variable",
values_from = "value"
)
# Calculate n, p, t
n <- length(unique(data_wide$id))
(65+55+50+55+51+55+45)/7
setwd("~/Library/CloudStorage/OneDrive-TheUniversityofMelbourne/Documents/ALL/PostDoc/tensorPLS/tensorOmics/CS1")
merged_df <- read.csv("data/logfoldChangeData.csv", header = TRUE)
save(merged_df, file = "data/antibioticStudy.Rdata")
